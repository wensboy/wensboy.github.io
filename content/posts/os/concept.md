## 前言

os的核心总是围绕4大基本功能来讲述的, 这主要包含: 进程管理, 内存管理, 设备管理, 文件系统. 实际上有些时候会将用户接口作为第五功能, 但是这是一个很泛的概念, 这没有任何问题, 但是不是这里详细讨论的对象. 主要围绕核心的基本功能记录, 同时也是一种内容快速参考, 因此会不定时纠正错误信息和补充.

## TOC

[概述](#概述)
[处理](#处理)
[存储](#存储)
[文件系统](#文件系统)
[设备](#设备)
~~[接口](#接口)~~

### 概述

从计算机组成学习中可以很快地发现计算机由不同硬件控件构成, 也能很快从中发掘一个问题: 控件如何交流协作处理事情? 为什么可以这样想: 控件的基本特征决定了其作用, 直观表现为能够做到某些实际的任务. 针对散件, 他们不能独自处理任务, 需要组合起来协作, 但是协作如果针对不同的其他控件要单独想一套交互体系, 那么系统将会变得前所未有的复杂. os则是被设计出来专门处理这样一类问题的. 

os有4大基本特征: 并发(微观交替宏观同时), 共享(资源使用), 虚拟(逻辑划分), 异步(不需要等待)

关于虚拟机: 实际上将具备软件功能的裸机称为虚拟机器. 一般的应用程序无法直接在无os的裸机上直接运行, 但是类似bios之类的bootloader程序可以, 该类程序属于硬件级别的编码程序, 即嵌入式开发. 其本质上就是思考: 如何让cpu进入指令执行循环.

os发展: 手动阶段(cpu和i/o不平衡)->批处理(传送带式io依然无法平衡cpu处理速度)->分时(允许人机交互,并在处理上很大改善)->实时(处理紧急任务)->网络和分布式(并行计算和数据控件共享)->现代化pc(较完善)

**os运行环境:**

处理器模型: 处理器能够在不同状态(内核|用户)下执行不同程序(内核程序和用户程序), 同时执行的指令主要划分为特权和非特权指令.

标准os组成由上层的管理模块和底层的硬件模块构成, 2部分共同组合为os内核. 内核主要解决: 时钟管理(任务执行的记录), 中断处理(cpu切换回os), 原语(原子指令), 系统数据结构和处理.

异常和中断差异: 异常无法被屏蔽, 中断在走特定总线时可以屏蔽. 软件中断一般属于异常, 需要立即处理. 

系统调用: lib一般对底层syscall进行封装, 系统调用可以看作为一种用户态程序接口, 用于在一定程度上访问特权指令(本质上是切换到内核态执行执行的内核程序).

os结构: 分层(复杂交互), 模块(边界接口模糊), 宏内核(复杂), 微内核(频繁状态切换导致效率低), 外核(难保证一致性).

os引导: bios加电自检后从rom中加载bootloader到内存, bootloader尝试将mbr加载到内存执行后找到活动分区(包含os的分区), pbr被加载到内存执行后找到os启动管理器后由os启动管理器将os内核读取到ram后, bootloader将cpu执行交给内核处理.

广义虚拟机: 一类虚拟机直接作为操作系统唯一运行在内核态, 其余虚拟设备作为一个进程在用户空间和执行; 二类虚拟机直接作为进程运行. 目前广为使用的是第二类虚拟机, 因为可移植性更强.

### 处理

关于程序和作业: 程序是处于磁盘中的一个可分配资源的实体镜像; 作业是用户输入的包含执行任务的项. 作业可以看作是一个程序向进程转变的中间过程.

进程实体(进程时刻状态): 主要由pcb,程序段和数据段组成. pcb是进程的唯一标识, 记录了关于进程执行期间的所有状态和资源使用.

进程: 进程实体的运行状态. 进程是动态, 隔离, 并发, 异步, 结构的. 

进程状态: 

```md
创建态 --> 就绪态 --> 运行态 --> 终止态
       ^            ^
        \          /
         \__阻塞态_/
创建: 初始化资源分配和pcb
就绪: 等待被调度分配cpu
运行: 获取cpu执行
阻塞: 被中断等待,将回到就绪态等待重新调度
终止: 进程退出, 删除pcb
```

进程组织: 较多为双向链表和索引表(linux中采用的双向链表组合红黑树,树结构在爆炸递增中常用于压缩搜索复杂度).

进程控制: 控制进程的状态切换(一般借助原语实现)

```cpp
/* 借用信号量中的pv操作来代表资源的请求和释放操作 */
// 进程创建: 创建态->就绪态
atomic {
    p(empty pcb);
    p(resources);
    write(pcb,resources);
    push(ready_queue,pcb);
}
// 进程终止: ->终止态
atomic {
    find(pcb_queue,pcb);
    if (pcb.is_running()){
        v(cpu);
    }
    loop {
        if(!pcb.childrens.next())break;
        v(pcb.childrens.next());
    }
    v(pcb.resources);
    v(pcb);
}
// 进程阻塞: 运行态->阻塞态
atomic {
    find(pcb_queue,pcb);
    if(pcb.is_running()){
        ss(pcb);
    }
    sleep(pcb);
    push(event_queue,pcb);
}
// 进程唤醒: 阻塞态->就绪态
atomic {
    find(event_queue,pcb);
    push(ready_queue,pcb);
}
// 进程切换: 就绪态->运行态, 运行态->就绪态
atomic {
    ss(pcb);
    push(select_queue,pcb);
    cpu.run(o_pcb);
}
```

进程通信: 低级pv操作, 高级共享内存,管道和消息.

```cpp
        低级: 基于固定数据结构
       / 
共享内存
       \   
        高级: 基于存储块
消息: 基于发送消息/接收消息原语
管道: 基于内存缓冲区和互斥/同步机制, 管道本质上就是一种特殊固定大小的内存缓冲, 在通信时满足channel特性. 在读空管道和写满管道时会阻塞进程. 至少需要2个管道才能实现全双工通信, 同时, 在多生产者-消费者模型下存在读混乱和数据丢失问题, 主要通过多写单读和多写轮询读来处理. 管道一般只用于父子进程通信, 因为管道只能被创建进程访问.
```

线程: 内核线程/用户线程, 线程本质上是轻量级进程, 在linux中内核线程其实本质上直接通过和进程统一个数据结构记录, 只是共享了进程的资源. 引入的原因主要为提高cpu执行的速率, 减少上下文切换的开销.

进程调度: 从就绪队列总通过一定的算法将进程加载到cpu中执行. 进程调度一般区分为: 高级(外存->内存), 中级(外存->内存), 低级(内存->cpu). 发生频率依次增加, 低级调度是最基本的调度, 用于选择进程执行. 高级调度一般发生在批处理系统中将外存作业从后备队列中调度到内存的就绪队列; 中级调度一般从外存的挂起队列中将挂起进程调度到内存的就绪队列或者阻塞挂起队列中; 低级调度一般直接从内存的就绪队列中选择进程调度到cpu中执行.

挂起和阻塞: 挂起是将暂时无法执行的进程调出内存, 阻塞是进程因为等待事件所以在内存中无法被调度. 阻塞和挂起可以同时发生, 返回时回到内存阻塞挂起队列中等待事件. 

调度器组成: 排队器(将就绪进程放入就绪队列)->分配器(加载指定进程进入cpu执行)->上下文切换器(加载分配器上下文执行分配器;移出分配器上下文,加载新进程到cpu)

调度时机: 允许调度(进程结束;进程意外终止;进程阻塞;时间片用完;高优先级抢占), 不允许调度(中断;原子操作;临界区)

调度方式: 协作式(主动让出cpu), 抢占式(优先级处理)

idle进程: 调度时永远无法被阻塞的兜底进程, 在linux中作为pid=0的全局父进程.

**调度算法**

非抢占: 执行期间cpu无法被剥夺<br>
抢占: 执行期间cpu可以直接被剥夺

先来先服务(fcfs): 非抢占式<br>
短作业优先(sjf): 非抢占式<br>
短进程优先(spf): 非抢占式<br>
最短剩余时间优先(srtf): 抢占式<br>
高响应比优先(hrrn): 非抢占式<br>
时间片轮转(rr): 抢占式<br>
优先级调度: 非抢占/抢占<br>
多级队列调度: 非抢占/抢占<br>
多级反馈队列: 抢占

**同步与互斥**

临界区: 访问临界资源的代码段<br>
临界资源: 同一时间只允许一个处理单位访问的资源<br>
访问特点: 空闲让进;忙则等待;有限等待;让权等待.

软件实现: 单标记法;双标记法后检测;双标记法先检测;peterson算法.

硬件实现: 中断关闭;

真正处理方式: 互斥锁;信号量.

**经典同步问题**

生产者-消费者问题

问题描述: 单个生产者和单个消费者通过一个缓冲大小为n的缓冲队列交互信息, 规定每次只能存在一个进程访问缓冲, 同时缓冲在不能再写时和不能再读时阻塞对应进程.

```cpp
// 定义信号量
// std::vector<auto> buf;
auto mutex = 1;
auto empty = n;
auto full = 0;

producer {
    do {
        auto product = make_product();
        p(empty);
        p(mutex);
        buf.push_back(product);
        v(mutex);
        v(full);
    }while(1)
}

consumer {
    do {
        p(full);
        p(mutex);
        buf.pop_back();
        v(mutex);
        v(empty);
    }while(1)
}
// p无法交换: 否则存在死锁
```

多生产者-多消费者

问题: 多个生产者和多个消费者通过一个缓冲为1的缓冲区来进行数据交互, 规定指定编号的生产者和消费者信息对应传输, 不能交叉.

```cpp
// 定义信号量
// size(buf)>1时需要存在互斥变量
auto s1 = 0;
auto s2 = 0;
auto buf =1;

producer1 {
    p(buf);
    v(s1);
}

producer2 {
    p(buf);
    v(s2);
}

consumer1 {
    p(s1);
    v(buf);
}

consumer2 {
    p(s2);
    v(buf);
}
```

读-写

问题: 一组读和写操作文件, 允许同时读, 但是不能在写时读, 不能同时写, 允许同时读.

```cpp
// 定义信号量
auto rw = 1;
auto r_count = 0;
auto mutex = 1;
auto w = 1;

writer {
    p(w);
    p(rw);
    write();
    v(rw);
    v(w);
} 

reader {
    p(w);
    p(mutex);
    if(r_count==0)p(rw);
    r_count++;
    v(mutex);
    v(w);
    read();
    p(mutex);
    p(r_count)v(rw);
    r_count--;
    v(mutex);
}
```

哲学家进餐

问题: 5个哲学家和5根筷子, 哲学家必须同时持有2根筷子才能正常吃饭.

```cpp
// 定义信号量
auto chopstick = {1,1,1,1,1};
auto mutex = 1;

Pi {
    p(mutex);
    p(chopstick[i]);
    p(chopstick[i+1%5]);
    v(mutex);
    eat();
    v(chopstick[i]);
    v(chopstick[i+1%5]);
}
```

吸烟

问题: 一个供应者可以随机向3个抽烟者提供缺少的材料以供卷烟抽, 实现轮流抽烟.

```cpp
auto o1 = 0;
auto o2 = 0;
auto o3 = 0;
auto finish = 0;
auto i = 0;

provider {
    switch(i){
        case 0:
        v(o1);
        break;
        case 1:
        v(o2);
        break;
        case 2:
        v(o3);
        break;
    }
    put_material();
    i = i+1%3
    p(finish);
}

s1 {
    p(o1);
    smoke();
    v(finish);
}

s2 {
    p(o2);
    smoke();
    v(finish);
}

s3 {
    p(o3);
    smoke();
    v(finish);
}
```

所有基于信号量的问题基于事件和同步互斥关系进行分析.

**死锁**

本质: 互相等待资源导致的所有进程无法正常执行下去.

四要素: 互斥;持有并请求;不可剥夺;循环等待.

进程图存在单资源的循环单向图, 则必然发生死锁.

死锁解决方案: 预防;避免;检测

死锁预防: 破坏死锁必要条件

死锁避免: 系统安全状态(安全状态:包含至少一个安全序列的状态,不安全状态:可能发生死锁), 银行家算法

死锁检测和解除: 资源分配图检测死锁(不可完全简化,则系统发生死锁); 解除(资源掠夺,撤销进程,进程回退)

### 存储

内存管理: 对内存的划分和动态分配过程

程序执行流程(内存视角): 编辑源代码->编译器编译->链接器构建内存装入和逻辑地址->装载到内存,转换逻辑地址到物理地址->就绪->获取cpu执行

**链接**

静态链接: 完整链接后装入内存中, 如果需要内存>可用内存, 程序无法装载<br>
动态链接: 装入内存时动态链接<br>
运行链接: 运行时链接

**装入**

绝对装入: 直接按照绝对地址装入内存<br>
重定向装入: 通过逻辑地址->物理地址转换后装入内存, 静态重定向(装入时重定向计算物理地址), 动态重定向(运行时参照寄存器进行求地址)

**内存分配**

内存主要分为: 内核区和用户区

单一分区分配: 用户区同一时刻只能存在一个进程, 通过覆盖式进行内存装入管理<br>
固定分区分配: 用户区划分为块, 依赖区的大小划分<br>
动态分区分配: 动态计算进程进入内存的大小进行分配内存

**内存管理**

分页式内存管理: 将内存划分为固定大小的块进行分配. 分页式结构结构定义通常为页框(2^12),页框数目(32bit下2^20), 因此针对一般的页表项最小用3byte标识(页表项虽然由页号和块号组成,但是通常页号在内存中连续排布,不占空间). 物理地址=块号*页框大小+页内逻辑地址(逻辑地址%页大小), 块号=页表(逻辑地址/页大小). 分页管理直观理解为切割进程块装入内存槽中. 关于n级页表, 通常而言设计和计算按照页表项4byte计算得到: 一个块最多存储2^12/4=2^10页表, 在30位逻辑结构下, 12位用于页内偏移, 10位用于二级页表, 8位用于一级页表. 采用分页的主要目的为: 高效内存利用. 2次访问主存: 页表->物理地址

分段式内存管理: 直接按照程序的逻辑段进行划分处理, 对开发人员友好. 基本概念和分页式内存管理基本一致. 段表主要组成: 段基址和段内偏移. 段表长度一般一致, 因此段号(逻辑分段)省略(内存中连续). 采用分段的主要目的为: 控制内存的共享和保护. 2次访问主存: 段表->物理地址

段页式内存管理: 结合分页和分段的优点在一定程度上进行优化. 段页项格式: 16位段号, 4位页号, 12位页偏移. 具体操作和分页和分段结合一致. 3次访问主存: 段表->页表->物理地址

**虚拟内存管理**

请求分页内存管理: 和基本分页内存管理基本一致, 如果使用过linux就知道swap其实就是外存中的置换区(用于在缺页时和内存进行换出和调入). 外存中还存在文件区, 不过从最终的构建文件系统就可以看出来置换区的文件系统和单纯的文件区不一致(加快io操作). 在unix中的调入思路是: 文件区的内容可以看作是默认读的, 当需要置换时, 可以直接从文件区置换页面(慢速io操作), 当页面在内存中存在修改时, 标记修改位后, 再换出到置换区(快速io), 后续直接从置换区调入. 关于缺页中断和一般中断的差异: 缺页中断是在执行指令期间发生, 而一般中断是在指令执行结束后发生. 请求分页虚拟内存在执行上只是在基本分页上增加访问页表找实际内存块(物理地址)时, 判断是否所需的页在内存中, 如果在内存中直接计算物理地址访问, 如果不在, 则触发缺页中断由缺页中断处理程序执行后续的页调入操作, 缺页中断属于内部异常. 置换时机主要为: 内存不足, 程序需要访问不在内存中页.

置换算法(操作系统无剩余空间): 最佳置换算法(opt), 先进先出(fifo), 最近最少使用(lru), 最近未使用(nru). 最接近opt算法的是改进clock算法: 通过(1bit,1bit)标识访问和修改, 没修改>修改, 没访问>访问

(访问, 修改):(0,0), 置换优先级为: (0,0)>(0,1)>(1,0)>(1,1), 相当于二进制逆序排列

由于clock算法的开销和复杂程度适中, 因此为目前较优的算法.

抖动和工作集: 抖动是频繁缺页中断进行页面置换导致的cpu利用率骤降的现象, 主要原因是: 工作集合在大部分时间大于系统分配的物理块大小, 导致频繁存在换页问题. 因此一般而言物理页数量要大于工作集. 系统需要避免抖动发生.

### 文件系统

#### 文件

文件系统: 对文件(具备定义的最小io操作的单位)进行动态管理(读取,修改,保存)的系统称为文件系统. 文件组成: 数据空间, 标签, 访问权限. 文件结构: 数据(基本->组合), 记录(多数据), 文件(多记录数据集). csapp上将纯粹的由ascii字符构成的文件称为纯文本文件, 其余文件则称为二进制文件, 大多源代码文件是utf-8编码的二进制文件. 支持utf-8字符集的原因在于分割时采用utf-8编码分割token, 因此string类型无法直接比较. 文件一般由fcb和inode控制, 文件属性: 文件名, 文件类型, 文件大小, 文件访问权限, 文件所有者和所有组, 文件修改日期, 文件物理地址, fcb为目录项, 多个fcb构成目录, inode一般分为磁盘索引节点和内存索引节点, 磁盘索引节点记录磁盘中文件的元信息, 当需要访问时加载到内存的索引节点, 并增加部分标记字段. 

文件操作: 创建, 读取, 修改, 删除, 重定向, 截断(通过syscall实), 思想为: 组合优于整体, 就像所有的数据库操作本质上都可以抽象为crud元操作, 然后组合, 只是需要权衡开销.

打开,关闭文件: 文件在内核空间采用二级表结构, 这个直观理解为文件本质上是唯一资源, 不必为每个需要打开的进程留存一个副本, 这样不论开销还是占用都很大. 系统打开表维护唯一资源记录(fcb和数据块), 进程打开表维护指针和权限. 打开文件一般先查进程打开表, 如果没有, 则将文件信息复制到系统打开表中后让进程打开表链接到系统打开表, 关闭文件则一般先查找并释放指定打开表的内存空间后, 系统打开表指定文件计数器-1操作.

文件保护: 口令(不安全), 密码加密(耗时), 访问控制(通过acl访问控制表进行,参考linux文件系统的精简acl(基于用户,组,其他的三级访问控制))

文件结构: 逻辑结构(顺序,索引,索引顺序,哈希), 物理结构(顺序,链式,索引)

文件结构补充: emm...也许文件和内存应当是一致性设计的. 实际上是这样的, 也许我们需要共用一套抽象, 而不是重新想其他方案. 怎么简单理解逻辑和物理结构: 在一般性的概念上而言, 逻辑是理论上的抽象, 不需要直接先考虑; 而物理是实际上的, 也就是真实的表现形式. 用一个文件简单举例就是: 文件内部的组织形式就是逻辑结构, 而文件在物理磁盘上的存储就是物理结构. 逻辑块将可见范围缩小到文件内部, 而物理块是实际存在磁盘中的. 对于逻辑结构而言, 杂乱无章的二进制文件就是一种无结构化的文件组织形式, 而诸如一些指定格式的文件其内部采用结构化的组织, 主要基于索引的形式. 而对于物理结构而言, 本质上就是物理磁盘上的数据存储的实际方式. 针对链式结构, 其实包含隐式(基于指针,多次访盘), 显式(fat直接存储头指针,在磁盘外计算地址即可)两种链式方式.

#### 目录

目录是fcb集合, 内部包含多个fcb, 用于组织多用户系统下的文件控制.

目录结构: 单级目录结构(线性fcb),二级别结构(用户区分,内层无法分组),树形(现代化目录结构)

文件共享: 通过在树形文件目录中添加有向边实现共享文件, 这不会构成一个有向无环图, 当节点入度=0时文件被删除. 

目录实现: 线性,散列(hash实现)

#### 文件系统

文件系统本质上是系统基于文件操作的系统化流程, 一般从用户调用操作系统接口开始, 到物理文件系统操作磁盘为底, 最后返回用户接口处得到结果.

文件系统在磁盘中主要在每个分区的头部控制整个分区的文件系统结构, 当需要加载内部文件进入内存时, 先查找指定目录总的fcb块复制到内存中的系统打开表中, 再通过请求进程打开表链接到系统打开表实现完整的控制. 文件系统通过多种方式管理存储空间. 包含文件系统的物理分区通过直接称为卷(volume).

#### 虚拟文件系统(vfs)

vfs的核心主要是屏蔽不同文件系统带来的系统调用操作差异, 从而为文件系统操作提供同一抽象.

linux抽象: 超级块, 索引节点, 目录项, 文件

磁盘分区和挂载: 分区主要划分逻辑磁盘块进行底层格式化, 用于安装指定文件系统到磁盘中; 挂载指将分区中的文件系统装载到vfs中, 通过vfs在unix目录树中分配实际的空间, unix目录树是一个固定的逻辑结构, 如果不分配卷, 就无法操作, 也就是无实际操作标记.

### 设备

#### io设备

io接口: 定义cpu如何和io设备交流数据, 本质上就是指设备控制器, 主板上对应设备处理芯片(替代以前的南桥)

io端口: 设备控制器中可以直接被cpu访问的春初寄存器

io控制: cpu直接控制(轮询); 中断(设备控制器主动); dma(直接内存操作,数据离散时退化为中断); 通道(实现复杂)

设备控制方式细节补充: 主要分为4种控制方式[程序直接控制, 中断控制, dma控制, 通道处理机控制]. 程序直接控制强调cpu强干预通过轮询的方式不断检测设备准备状态, 属于字符传输方式; 中断控制则通过设备控制器在必要时主动中断, cpu仅仅在中断时介入; dma则通过连接内存和设备, 通过dma控制直接将io<->内存的步骤解放cpu, 并升级为块传输, cpu仅仅在块开始和结束介入. 通道直接通过隔离计算, 将cpu和设备直接解耦, cpu仅需要向通道处理机交互即可和设备完成io处理, 通道程序在内存中. 

io层次: 用户层->设备独立软件->设备驱动程序->中断处理程序->硬件处理

关于io层次补充: 全程只发生一次中断, 并且属于内中断(异常), 为正常指令执行期间的io操作. 大致执行流程如下: 用户通过程序接口进行syscall调用, syscall立刻被设备独立程序解析到执行设备驱动处, 设备驱动唤起指定设备发起中断, cpu跳转到指定中断位置进行syscall中断处理完成过程.

io程序接口: 字符接口(中断); 块接口(dma); 网络接口(套接字); 阻塞和非阻塞io接口(同步和异步)

设备独立程序(数据控制): cache(内存)和buffer(单buf,双buf,循环buf,buf pool)

设备分配与回收: 设备分配的核心任务就是预防死锁和高效分配给进程使用. 四大控制表: 设备控制表(dct),控制器控制表(coct),通道控制表(chct),系统设备表(sdt), 当然为了高效在多用户系统下分配设备, 通常需要逻辑设备表(lut)来做逻辑设备到物理设备的映射. 分配方式主要包含: 静态分配(安装状态), 动态分配(不安全状态,需要通过死锁避免和检测解除手段). 现代化的os通常为多用户操作系统, 因此一般的唯一资源需要借助逻辑到实际的映射来实现资源分配.

设备分配实际图:

```md
     __dct->coct->chct
    /
sdt ---...
    \
     \__dct->jcoct->chct
1. 分配方式主要划分为: 静态和动态, 安全和不安全
静态->在进程执行开始时一次性将资源分配给进程
动态->在进程执行期间分配
安全->分配完阻塞进程
不安全->不直接阻塞进程,直到无法分配设备时阻塞
2. 分配流程: sdt->dct->coct->chct->操作设备
3. lut引入提高了设备之间映射的灵活性
```

#### 磁盘

磁盘结构: 磁头, 扇区, 磁道, 扇区间隙, 磁道间隙, 盘面, 柱面. 

磁盘寻址: 柱面号->盘面号->扇区号

相关计算: 

ts(寻道时间) = m(磁头启动时间) + n*v(磁头移动n个磁道时间)<br>
tr(延迟时间) = 1/2\*1/r(转速) = 1/2\*r
tt(读写时间) = 1/r*b(b个字节)/N(每个磁道的字节数)
平均存取时间 = ts + tr + tt

分类: 头可动, 头固定, 盘固定, 盘可动

磁盘管理: 初始化->分区->引导->坏块->减少磁盘延迟

磁盘调度算法: 先来先服务(fcfs), 最短搜索时间优先(sstf), 扫描算法(scan), look算法, c-scan算法, c-look算法. 显然sstf和标准look算法的平均寻道时间基本将保持最短, 基于贪心的算法.

磁盘调度算法补充: fcfs按照请求顺序寻道; sstf总是按照离当前最短的磁道寻道; scan算法先向外后向内不断循环寻道; look算法在单方向上如果不存在更多请求后转向; c-scan在转向时直接回到起始; c-look在转向后回到方向最后磁道上.

#### 固态硬盘

采用闪存技术, 属于电可rom, 存在磨损. 通过擦除均衡技术延长寿命, 速度比机械磁盘快, 内部采用页结构构成块存储数据. 

### ~~接口~~

## REFERENCE

[王道os-个人笔记](https://www.cnblogs.com/zhaoyiyang/articles/17816903.html)